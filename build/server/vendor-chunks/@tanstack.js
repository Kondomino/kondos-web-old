"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll),\n/* harmony export */   measureElement: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect),\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer),\n/* harmony export */   windowScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n\n\n\n\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n    const rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(()=>({}), {})[1];\n    const resolvedOptions = {\n        ...options,\n        onChange: (instance2, sync)=>{\n            var _a;\n            if (sync) {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n            } else {\n                rerender();\n            }\n            (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n        }\n    };\n    const [instance] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions));\n    instance.setOptions(resolvedOptions);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return instance._didMount();\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        return instance._willUpdate();\n    });\n    return instance;\n}\nfunction useVirtualizer(options) {\n    return useVirtualizerBase({\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll,\n        ...options\n    });\n}\nfunction useWindowVirtualizer(options) {\n    return useVirtualizerBase({\n        getScrollElement: ()=>typeof document !== \"undefined\" ? window : null,\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n        initialOffset: ()=>typeof document !== \"undefined\" ? window.scrollY : 0,\n        ...options\n    });\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNPO0FBQzhIO0FBQzdIO0FBQ3ZDLE1BQU1TLDRCQUE0QixPQUFPQyxhQUFhLGNBQWNWLGtEQUFxQixHQUFHQSw0Q0FBZTtBQUMzRyxTQUFTYSxtQkFBbUJDLE9BQU87SUFDakMsTUFBTUMsV0FBV2YsNkNBQWdCLENBQUMsSUFBTyxFQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNwRCxNQUFNaUIsa0JBQWtCO1FBQ3RCLEdBQUdILE9BQU87UUFDVkksVUFBVSxDQUFDQyxXQUFXQztZQUNwQixJQUFJQztZQUNKLElBQUlELE1BQU07Z0JBQ1JuQixvREFBU0EsQ0FBQ2M7WUFDWixPQUFPO2dCQUNMQTtZQUNGO1lBQ0NNLENBQUFBLEtBQUtQLFFBQVFJLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSUcsR0FBR0MsSUFBSSxDQUFDUixTQUFTSyxXQUFXQztRQUN6RTtJQUNGO0lBQ0EsTUFBTSxDQUFDRyxTQUFTLEdBQUd2QiwyQ0FBYyxDQUMvQixJQUFNLElBQUlRLCtEQUFXQSxDQUFDUztJQUV4Qk0sU0FBU0UsVUFBVSxDQUFDUjtJQUNwQmpCLDRDQUFlLENBQUM7UUFDZCxPQUFPdUIsU0FBU0csU0FBUztJQUMzQixHQUFHLEVBQUU7SUFDTGpCLDBCQUEwQjtRQUN4QixPQUFPYyxTQUFTSSxXQUFXO0lBQzdCO0lBQ0EsT0FBT0o7QUFDVDtBQUNBLFNBQVNLLGVBQWVkLE9BQU87SUFDN0IsT0FBT0QsbUJBQW1CO1FBQ3hCWCxrQkFBa0JBLHdFQUFBQTtRQUNsQkMsb0JBQW9CQSwwRUFBQUE7UUFDcEIwQixZQUFZekIsaUVBQWFBO1FBQ3pCLEdBQUdVLE9BQU87SUFDWjtBQUNGO0FBQ0EsU0FBU2dCLHFCQUFxQmhCLE9BQU87SUFDbkMsT0FBT0QsbUJBQW1CO1FBQ3hCa0Isa0JBQWtCLElBQU0sT0FBT3JCLGFBQWEsY0FBY3NCLFNBQVM7UUFDbkU5QixvQkFBb0JHLHFFQUFpQkE7UUFDckNGLHNCQUFzQkcsdUVBQW1CQTtRQUN6Q3VCLFlBQVl0QixnRUFBWUE7UUFDeEIwQixlQUFlLElBQU0sT0FBT3ZCLGFBQWEsY0FBY3NCLE9BQU9FLE9BQU8sR0FBRztRQUN4RSxHQUFHcEIsT0FBTztJQUNaO0FBQ0Y7QUFJRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25jbWF6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdmlydHVhbC9kaXN0L2VzbS9pbmRleC5qcz85YmY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgb2JzZXJ2ZUVsZW1lbnRSZWN0LCBvYnNlcnZlRWxlbWVudE9mZnNldCwgZWxlbWVudFNjcm9sbCwgb2JzZXJ2ZVdpbmRvd1JlY3QsIG9ic2VydmVXaW5kb3dPZmZzZXQsIHdpbmRvd1Njcm9sbCwgVmlydHVhbGl6ZXIgfSBmcm9tIFwiQHRhbnN0YWNrL3ZpcnR1YWwtY29yZVwiO1xuZXhwb3J0ICogZnJvbSBcIkB0YW5zdGFjay92aXJ0dWFsLWNvcmVcIjtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplckJhc2Uob3B0aW9ucykge1xuICBjb25zdCByZXJlbmRlciA9IFJlYWN0LnVzZVJlZHVjZXIoKCkgPT4gKHt9KSwge30pWzFdO1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBvbkNoYW5nZTogKGluc3RhbmNlMiwgc3luYykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgZmx1c2hTeW5jKHJlcmVuZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcmVuZGVyKCk7XG4gICAgICB9XG4gICAgICAoX2EgPSBvcHRpb25zLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBpbnN0YW5jZTIsIHN5bmMpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgW2luc3RhbmNlXSA9IFJlYWN0LnVzZVN0YXRlKFxuICAgICgpID0+IG5ldyBWaXJ0dWFsaXplcihyZXNvbHZlZE9wdGlvbnMpXG4gICk7XG4gIGluc3RhbmNlLnNldE9wdGlvbnMocmVzb2x2ZWRPcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2RpZE1vdW50KCk7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl93aWxsVXBkYXRlKCk7XG4gIH0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiB1c2VWaXJ0dWFsaXplckJhc2Uoe1xuICAgIG9ic2VydmVFbGVtZW50UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldCxcbiAgICBzY3JvbGxUb0ZuOiBlbGVtZW50U2Nyb2xsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VXaW5kb3dWaXJ0dWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiB1c2VWaXJ0dWFsaXplckJhc2Uoe1xuICAgIGdldFNjcm9sbEVsZW1lbnQ6ICgpID0+IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGwsXG4gICAgb2JzZXJ2ZUVsZW1lbnRSZWN0OiBvYnNlcnZlV2luZG93UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldDogb2JzZXJ2ZVdpbmRvd09mZnNldCxcbiAgICBzY3JvbGxUb0ZuOiB3aW5kb3dTY3JvbGwsXG4gICAgaW5pdGlhbE9mZnNldDogKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnNjcm9sbFkgOiAwLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5leHBvcnQge1xuICB1c2VWaXJ0dWFsaXplcixcbiAgdXNlV2luZG93VmlydHVhbGl6ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImZsdXNoU3luYyIsIm9ic2VydmVFbGVtZW50UmVjdCIsIm9ic2VydmVFbGVtZW50T2Zmc2V0IiwiZWxlbWVudFNjcm9sbCIsIm9ic2VydmVXaW5kb3dSZWN0Iiwib2JzZXJ2ZVdpbmRvd09mZnNldCIsIndpbmRvd1Njcm9sbCIsIlZpcnR1YWxpemVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImRvY3VtZW50IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlVmlydHVhbGl6ZXJCYXNlIiwib3B0aW9ucyIsInJlcmVuZGVyIiwidXNlUmVkdWNlciIsInJlc29sdmVkT3B0aW9ucyIsIm9uQ2hhbmdlIiwiaW5zdGFuY2UyIiwic3luYyIsIl9hIiwiY2FsbCIsImluc3RhbmNlIiwidXNlU3RhdGUiLCJzZXRPcHRpb25zIiwiX2RpZE1vdW50IiwiX3dpbGxVcGRhdGUiLCJ1c2VWaXJ0dWFsaXplciIsInNjcm9sbFRvRm4iLCJ1c2VXaW5kb3dWaXJ0dWFsaXplciIsImdldFNjcm9sbEVsZW1lbnQiLCJ3aW5kb3ciLCJpbml0aWFsT2Zmc2V0Iiwic2Nyb2xsWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst defaultKeyExtractor = (index)=>index;\nconst defaultRangeExtractor = (range)=>{\n    const start = Math.max(range.startIndex - range.overscan, 0);\n    const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n    const arr = [];\n    for(let i = start; i <= end; i++){\n        arr.push(i);\n    }\n    return arr;\n};\nconst observeElementRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = (rect)=>{\n        const { width, height } = rect;\n        cb({\n            width: Math.round(width),\n            height: Math.round(height)\n        });\n    };\n    handler(element.getBoundingClientRect());\n    if (typeof ResizeObserver === \"undefined\") {\n        return ()=>{};\n    }\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        if (entry == null ? void 0 : entry.borderBoxSize) {\n            const box = entry.borderBoxSize[0];\n            if (box) {\n                handler({\n                    width: box.inlineSize,\n                    height: box.blockSize\n                });\n                return;\n            }\n        }\n        handler(element.getBoundingClientRect());\n    });\n    observer.observe(element, {\n        box: \"border-box\"\n    });\n    return ()=>{\n        observer.unobserve(element);\n    };\n};\nconst addEventListenerOptions = {\n    passive: true\n};\nconst observeWindowRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb({\n            width: element.innerWidth,\n            height: element.innerHeight\n        });\n    };\n    handler();\n    element.addEventListener(\"resize\", handler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"resize\", handler);\n    };\n};\nconst supportsScrollend =  true ? true : 0;\nconst observeElementOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    let offset = 0;\n    const fallback = supportsScrollend ? ()=>void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(()=>{\n        cb(offset, false);\n    }, instance.options.isScrollingResetDelay);\n    const createHandler = (isScrolling)=>()=>{\n            offset = element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"];\n            fallback();\n            cb(offset, isScrolling);\n        };\n    const handler = createHandler(true);\n    const endHandler = createHandler(false);\n    endHandler();\n    element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n        element.removeEventListener(\"scrollend\", endHandler);\n    };\n};\nconst observeWindowOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    let offset = 0;\n    const fallback = supportsScrollend ? ()=>void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(()=>{\n        cb(offset, false);\n    }, instance.options.isScrollingResetDelay);\n    const createHandler = (isScrolling)=>()=>{\n            offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n            fallback();\n            cb(offset, isScrolling);\n        };\n    const handler = createHandler(true);\n    const endHandler = createHandler(false);\n    endHandler();\n    element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n        element.removeEventListener(\"scrollend\", endHandler);\n    };\n};\nconst measureElement = (element, entry, instance)=>{\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n            const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n            return size;\n        }\n    }\n    return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nconst windowScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nconst elementScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nclass Virtualizer {\n    constructor(opts){\n        this.unsubs = [];\n        this.scrollElement = null;\n        this.isScrolling = false;\n        this.scrollToIndexTimeoutId = null;\n        this.measurementsCache = [];\n        this.itemSizeCache = /* @__PURE__ */ new Map();\n        this.pendingMeasuredCacheIndexes = [];\n        this.scrollDirection = null;\n        this.scrollAdjustments = 0;\n        this.measureElementCache = /* @__PURE__ */ new Map();\n        this.observer = /* @__PURE__ */ (()=>{\n            let _ro = null;\n            const get = ()=>{\n                if (_ro) {\n                    return _ro;\n                } else if (typeof ResizeObserver !== \"undefined\") {\n                    return _ro = new ResizeObserver((entries)=>{\n                        entries.forEach((entry)=>{\n                            this._measureElement(entry.target, entry);\n                        });\n                    });\n                } else {\n                    return null;\n                }\n            };\n            return {\n                disconnect: ()=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.disconnect();\n                },\n                observe: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.observe(target, {\n                        box: \"border-box\"\n                    });\n                },\n                unobserve: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.unobserve(target);\n                }\n            };\n        })();\n        this.range = null;\n        this.setOptions = (opts2)=>{\n            Object.entries(opts2).forEach(([key, value])=>{\n                if (typeof value === \"undefined\") delete opts2[key];\n            });\n            this.options = {\n                debug: false,\n                initialOffset: 0,\n                overscan: 1,\n                paddingStart: 0,\n                paddingEnd: 0,\n                scrollPaddingStart: 0,\n                scrollPaddingEnd: 0,\n                horizontal: false,\n                getItemKey: defaultKeyExtractor,\n                rangeExtractor: defaultRangeExtractor,\n                onChange: ()=>{},\n                measureElement,\n                initialRect: {\n                    width: 0,\n                    height: 0\n                },\n                scrollMargin: 0,\n                gap: 0,\n                indexAttribute: \"data-index\",\n                initialMeasurementsCache: [],\n                lanes: 1,\n                isScrollingResetDelay: 150,\n                ...opts2\n            };\n        };\n        this.notify = (force, sync)=>{\n            var _a, _b;\n            const { startIndex, endIndex } = this.range ?? {\n                startIndex: void 0,\n                endIndex: void 0\n            };\n            const range = this.calculateRange();\n            if (force || startIndex !== (range == null ? void 0 : range.startIndex) || endIndex !== (range == null ? void 0 : range.endIndex)) {\n                (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n            }\n        };\n        this.cleanup = ()=>{\n            this.unsubs.filter(Boolean).forEach((d)=>d());\n            this.unsubs = [];\n            this.scrollElement = null;\n        };\n        this._didMount = ()=>{\n            this.measureElementCache.forEach(this.observer.observe);\n            return ()=>{\n                this.observer.disconnect();\n                this.cleanup();\n            };\n        };\n        this._willUpdate = ()=>{\n            const scrollElement = this.options.getScrollElement();\n            if (this.scrollElement !== scrollElement) {\n                this.cleanup();\n                this.scrollElement = scrollElement;\n                this._scrollToOffset(this.scrollOffset, {\n                    adjustments: void 0,\n                    behavior: void 0\n                });\n                this.unsubs.push(this.options.observeElementRect(this, (rect)=>{\n                    this.scrollRect = rect;\n                    this.notify(false, false);\n                }));\n                this.unsubs.push(this.options.observeElementOffset(this, (offset, isScrolling)=>{\n                    this.scrollAdjustments = 0;\n                    this.scrollDirection = isScrolling ? this.scrollOffset < offset ? \"forward\" : \"backward\" : null;\n                    this.scrollOffset = offset;\n                    const prevIsScrolling = this.isScrolling;\n                    this.isScrolling = isScrolling;\n                    this.notify(prevIsScrolling !== isScrolling, isScrolling);\n                }));\n            }\n        };\n        this.getSize = ()=>{\n            return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n        };\n        this.getMeasurementOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.count,\n                this.options.paddingStart,\n                this.options.scrollMargin,\n                this.options.getItemKey\n            ], (count, paddingStart, scrollMargin, getItemKey)=>{\n            this.pendingMeasuredCacheIndexes = [];\n            return {\n                count,\n                paddingStart,\n                scrollMargin,\n                getItemKey\n            };\n        }, {\n            key: false\n        });\n        this.getFurthestMeasurement = (measurements, index)=>{\n            const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n            const furthestMeasurements = /* @__PURE__ */ new Map();\n            for(let m = index - 1; m >= 0; m--){\n                const measurement = measurements[m];\n                if (furthestMeasurementsFound.has(measurement.lane)) {\n                    continue;\n                }\n                const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n                if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n                    furthestMeasurements.set(measurement.lane, measurement);\n                } else if (measurement.end < previousFurthestMeasurement.end) {\n                    furthestMeasurementsFound.set(measurement.lane, true);\n                }\n                if (furthestMeasurementsFound.size === this.options.lanes) {\n                    break;\n                }\n            }\n            return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b)=>{\n                if (a.end === b.end) {\n                    return a.index - b.index;\n                }\n                return a.end - b.end;\n            })[0] : void 0;\n        };\n        this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurementOptions(),\n                this.itemSizeCache\n            ], ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache)=>{\n            const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n            this.pendingMeasuredCacheIndexes = [];\n            const measurements = this.measurementsCache.slice(0, min);\n            for(let i = min; i < count; i++){\n                const key = getItemKey(i);\n                const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n                const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n                const measuredSize = itemSizeCache.get(key);\n                const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n                const end = start + size;\n                const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n                measurements[i] = {\n                    index: i,\n                    start,\n                    size,\n                    end,\n                    key,\n                    lane\n                };\n            }\n            this.measurementsCache = measurements;\n            return measurements;\n        }, {\n            key:  true && \"getMeasurements\",\n            debug: ()=>this.options.debug\n        });\n        this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurements(),\n                this.getSize(),\n                this.scrollOffset\n            ], (measurements, outerSize, scrollOffset)=>{\n            return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n                measurements,\n                outerSize,\n                scrollOffset\n            }) : null;\n        }, {\n            key:  true && \"calculateRange\",\n            debug: ()=>this.options.debug\n        });\n        this.getIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.rangeExtractor,\n                this.calculateRange(),\n                this.options.overscan,\n                this.options.count\n            ], (rangeExtractor, range, overscan, count)=>{\n            return range === null ? [] : rangeExtractor({\n                startIndex: range.startIndex,\n                endIndex: range.endIndex,\n                overscan,\n                count\n            });\n        }, {\n            key:  true && \"getIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.indexFromElement = (node)=>{\n            const attributeName = this.options.indexAttribute;\n            const indexStr = node.getAttribute(attributeName);\n            if (!indexStr) {\n                console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n                return -1;\n            }\n            return parseInt(indexStr, 10);\n        };\n        this._measureElement = (node, entry)=>{\n            const item = this.measurementsCache[this.indexFromElement(node)];\n            if (!item || !node.isConnected) {\n                this.measureElementCache.forEach((cached, key)=>{\n                    if (cached === node) {\n                        this.observer.unobserve(node);\n                        this.measureElementCache.delete(key);\n                    }\n                });\n                return;\n            }\n            const prevNode = this.measureElementCache.get(item.key);\n            if (prevNode !== node) {\n                if (prevNode) {\n                    this.observer.unobserve(prevNode);\n                }\n                this.observer.observe(node);\n                this.measureElementCache.set(item.key, node);\n            }\n            const measuredItemSize = this.options.measureElement(node, entry, this);\n            this.resizeItem(item, measuredItemSize);\n        };\n        this.resizeItem = (item, size)=>{\n            const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n            const delta = size - itemSize;\n            if (delta !== 0) {\n                if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.scrollOffset + this.scrollAdjustments) {\n                    if ( true && this.options.debug) {\n                        console.info(\"correction\", delta);\n                    }\n                    this._scrollToOffset(this.scrollOffset, {\n                        adjustments: this.scrollAdjustments += delta,\n                        behavior: void 0\n                    });\n                }\n                this.pendingMeasuredCacheIndexes.push(item.index);\n                this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n                this.notify(true, false);\n            }\n        };\n        this.measureElement = (node)=>{\n            if (!node) {\n                return;\n            }\n            this._measureElement(node, void 0);\n        };\n        this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getIndexes(),\n                this.getMeasurements()\n            ], (indexes, measurements)=>{\n            const virtualItems = [];\n            for(let k = 0, len = indexes.length; k < len; k++){\n                const i = indexes[k];\n                const measurement = measurements[i];\n                virtualItems.push(measurement);\n            }\n            return virtualItems;\n        }, {\n            key:  true && \"getIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.getVirtualItemForOffset = (offset)=>{\n            const measurements = this.getMeasurements();\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[findNearestBinarySearch(0, measurements.length - 1, (index)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start, offset)]);\n        };\n        this.getOffsetForAlignment = (toOffset, align)=>{\n            const size = this.getSize();\n            if (align === \"auto\") {\n                if (toOffset <= this.scrollOffset) {\n                    align = \"start\";\n                } else if (toOffset >= this.scrollOffset + size) {\n                    align = \"end\";\n                } else {\n                    align = \"start\";\n                }\n            }\n            if (align === \"start\") {\n                toOffset = toOffset;\n            } else if (align === \"end\") {\n                toOffset = toOffset - size;\n            } else if (align === \"center\") {\n                toOffset = toOffset - size / 2;\n            }\n            const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n            const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n            const maxOffset = scrollSize - this.getSize();\n            return Math.max(Math.min(maxOffset, toOffset), 0);\n        };\n        this.getOffsetForIndex = (index, align = \"auto\")=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            const measurement = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(this.getMeasurements()[index]);\n            if (align === \"auto\") {\n                if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n                    align = \"end\";\n                } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n                    align = \"start\";\n                } else {\n                    return [\n                        this.scrollOffset,\n                        align\n                    ];\n                }\n            }\n            const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n            return [\n                this.getOffsetForAlignment(toOffset, align),\n                align\n            ];\n        };\n        this.isDynamicMode = ()=>this.measureElementCache.size > 0;\n        this.cancelScrollToIndex = ()=>{\n            if (this.scrollToIndexTimeoutId !== null) {\n                clearTimeout(this.scrollToIndexTimeoutId);\n                this.scrollToIndexTimeoutId = null;\n            }\n        };\n        this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {})=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n            this._scrollToOffset(toOffset, {\n                adjustments: void 0,\n                behavior\n            });\n            if (behavior !== \"smooth\" && this.isDynamicMode()) {\n                this.scrollToIndexTimeoutId = setTimeout(()=>{\n                    this.scrollToIndexTimeoutId = null;\n                    const elementInDOM = this.measureElementCache.has(this.options.getItemKey(index));\n                    if (elementInDOM) {\n                        const [toOffset2] = this.getOffsetForIndex(index, align);\n                        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(toOffset2, this.scrollOffset)) {\n                            this.scrollToIndex(index, {\n                                align,\n                                behavior\n                            });\n                        }\n                    } else {\n                        this.scrollToIndex(index, {\n                            align,\n                            behavior\n                        });\n                    }\n                });\n            }\n        };\n        this.scrollBy = (delta, { behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.scrollOffset + delta, {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.getTotalSize = ()=>{\n            var _a;\n            const measurements = this.getMeasurements();\n            let end;\n            if (measurements.length === 0) {\n                end = this.options.paddingStart;\n            } else {\n                end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(...measurements.slice(-this.options.lanes).map((m)=>m.end));\n            }\n            return end - this.options.scrollMargin + this.options.paddingEnd;\n        };\n        this._scrollToOffset = (offset, { adjustments, behavior })=>{\n            this.options.scrollToFn(offset, {\n                behavior,\n                adjustments\n            }, this);\n        };\n        this.measure = ()=>{\n            var _a, _b;\n            this.itemSizeCache = /* @__PURE__ */ new Map();\n            (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, false);\n        };\n        this.setOptions(opts);\n        this.scrollRect = this.options.initialRect;\n        this.scrollOffset = typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset;\n        this.measurementsCache = this.options.initialMeasurementsCache;\n        this.measurementsCache.forEach((item)=>{\n            this.itemSizeCache.set(item.key, item.size);\n        });\n        this.notify(false, false);\n    }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value)=>{\n    while(low <= high){\n        const middle = (low + high) / 2 | 0;\n        const currentValue = getCurrentValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        } else if (currentValue > value) {\n            high = middle - 1;\n        } else {\n            return middle;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n    const count = measurements.length - 1;\n    const getOffset = (index)=>measurements[index].start;\n    const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n    let endIndex = startIndex;\n    while(endIndex < count && measurements[endIndex].end < scrollOffset + outerSize){\n        endIndex++;\n    }\n    return {\n        startIndex,\n        endIndex\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDdkUsTUFBTUksc0JBQXNCLENBQUNDLFFBQVVBO0FBQ3ZDLE1BQU1DLHdCQUF3QixDQUFDQztJQUM3QixNQUFNQyxRQUFRQyxLQUFLQyxHQUFHLENBQUNILE1BQU1JLFVBQVUsR0FBR0osTUFBTUssUUFBUSxFQUFFO0lBQzFELE1BQU1DLE1BQU1KLEtBQUtLLEdBQUcsQ0FBQ1AsTUFBTVEsUUFBUSxHQUFHUixNQUFNSyxRQUFRLEVBQUVMLE1BQU1TLEtBQUssR0FBRztJQUNwRSxNQUFNQyxNQUFNLEVBQUU7SUFDZCxJQUFLLElBQUlDLElBQUlWLE9BQU9VLEtBQUtMLEtBQUtLLElBQUs7UUFDakNELElBQUlFLElBQUksQ0FBQ0Q7SUFDWDtJQUNBLE9BQU9EO0FBQ1Q7QUFDQSxNQUFNRyxxQkFBcUIsQ0FBQ0MsVUFBVUM7SUFDcEMsTUFBTUMsVUFBVUYsU0FBU0csYUFBYTtJQUN0QyxJQUFJLENBQUNELFNBQVM7UUFDWjtJQUNGO0lBQ0EsTUFBTUUsVUFBVSxDQUFDQztRQUNmLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBR0Y7UUFDMUJKLEdBQUc7WUFBRUssT0FBT2xCLEtBQUtvQixLQUFLLENBQUNGO1lBQVFDLFFBQVFuQixLQUFLb0IsS0FBSyxDQUFDRDtRQUFRO0lBQzVEO0lBQ0FILFFBQVFGLFFBQVFPLHFCQUFxQjtJQUNyQyxJQUFJLE9BQU9DLG1CQUFtQixhQUFhO1FBQ3pDLE9BQU8sS0FDUDtJQUNGO0lBQ0EsTUFBTUMsV0FBVyxJQUFJRCxlQUFlLENBQUNFO1FBQ25DLE1BQU1DLFFBQVFELE9BQU8sQ0FBQyxFQUFFO1FBQ3hCLElBQUlDLFNBQVMsT0FBTyxLQUFLLElBQUlBLE1BQU1DLGFBQWEsRUFBRTtZQUNoRCxNQUFNQyxNQUFNRixNQUFNQyxhQUFh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QU9BO1FBQ1Q7SUFDRjtJQUNBLElBQUlILE1BQU0sR0FBRztRQUNYLE9BQU9BLE1BQU07SUFDZixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFDQSxTQUFTdkYsZUFBZSxFQUN0QmUsWUFBWSxFQUNac0IsU0FBUyxFQUNUNUIsWUFBWSxFQUNiO0lBQ0MsTUFBTXpHLFFBQVErRyxhQUFhZ0IsTUFBTSxHQUFHO0lBQ3BDLE1BQU02RCxZQUFZLENBQUN2TSxRQUFVMEgsWUFBWSxDQUFDMUgsTUFBTSxDQUFDRyxLQUFLO0lBQ3RELE1BQU1HLGFBQWFxSyx3QkFBd0IsR0FBR2hLLE9BQU80TCxXQUFXbkY7SUFDaEUsSUFBSTFHLFdBQVdKO0lBQ2YsTUFBT0ksV0FBV0MsU0FBUytHLFlBQVksQ0FBQ2hILFNBQVMsQ0FBQ0YsR0FBRyxHQUFHNEcsZUFBZTRCLFVBQVc7UUFDaEZ0STtJQUNGO0lBQ0EsT0FBTztRQUFFSjtRQUFZSTtJQUFTO0FBQ2hDO0FBZ0JFLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmNtYXotbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvZGlzdC9lc20vaW5kZXguanM/YjY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWJvdW5jZSwgbWVtbywgbm90VW5kZWZpbmVkLCBhcHByb3hFcXVhbCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5jb25zdCBkZWZhdWx0S2V5RXh0cmFjdG9yID0gKGluZGV4KSA9PiBpbmRleDtcbmNvbnN0IGRlZmF1bHRSYW5nZUV4dHJhY3RvciA9IChyYW5nZSkgPT4ge1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0SW5kZXggLSByYW5nZS5vdmVyc2NhbiwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHJhbmdlLmVuZEluZGV4ICsgcmFuZ2Uub3ZlcnNjYW4sIHJhbmdlLmNvdW50IC0gMSk7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBhcnIucHVzaChpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbmNvbnN0IG9ic2VydmVFbGVtZW50UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKHJlY3QpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJlY3Q7XG4gICAgY2IoeyB3aWR0aDogTWF0aC5yb3VuZCh3aWR0aCksIGhlaWdodDogTWF0aC5yb3VuZChoZWlnaHQpIH0pO1xuICB9O1xuICBoYW5kbGVyKGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgICAgY29uc3QgYm94ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXTtcbiAgICAgIGlmIChib3gpIHtcbiAgICAgICAgaGFuZGxlcih7IHdpZHRoOiBib3guaW5saW5lU2l6ZSwgaGVpZ2h0OiBib3guYmxvY2tTaXplIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGhhbmRsZXIoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gIH07XG59O1xuY29uc3QgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5jb25zdCBvYnNlcnZlV2luZG93UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgIGNiKHsgd2lkdGg6IGVsZW1lbnQuaW5uZXJXaWR0aCwgaGVpZ2h0OiBlbGVtZW50LmlubmVySGVpZ2h0IH0pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZXIpO1xuICB9O1xufTtcbmNvbnN0IHN1cHBvcnRzU2Nyb2xsZW5kID0gdHlwZW9mIHdpbmRvdyA9PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IFwib25zY3JvbGxlbmRcIiBpbiB3aW5kb3c7XG5jb25zdCBvYnNlcnZlRWxlbWVudE9mZnNldCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmFsbGJhY2sgPSBzdXBwb3J0c1Njcm9sbGVuZCA/ICgpID0+IHZvaWQgMCA6IGRlYm91bmNlKCgpID0+IHtcbiAgICBjYihvZmZzZXQsIGZhbHNlKTtcbiAgfSwgaW5zdGFuY2Uub3B0aW9ucy5pc1Njcm9sbGluZ1Jlc2V0RGVsYXkpO1xuICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGlzU2Nyb2xsaW5nKSA9PiAoKSA9PiB7XG4gICAgb2Zmc2V0ID0gZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCJdO1xuICAgIGZhbGxiYWNrKCk7XG4gICAgY2Iob2Zmc2V0LCBpc1Njcm9sbGluZyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKHRydWUpO1xuICBjb25zdCBlbmRIYW5kbGVyID0gY3JlYXRlSGFuZGxlcihmYWxzZSk7XG4gIGVuZEhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIpO1xuICB9O1xufTtcbmNvbnN0IG9ic2VydmVXaW5kb3dPZmZzZXQgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZhbGxiYWNrID0gc3VwcG9ydHNTY3JvbGxlbmQgPyAoKSA9PiB2b2lkIDAgOiBkZWJvdW5jZSgoKSA9PiB7XG4gICAgY2Iob2Zmc2V0LCBmYWxzZSk7XG4gIH0sIGluc3RhbmNlLm9wdGlvbnMuaXNTY3JvbGxpbmdSZXNldERlbGF5KTtcbiAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChpc1Njcm9sbGluZykgPT4gKCkgPT4ge1xuICAgIG9mZnNldCA9IGVsZW1lbnRbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJzY3JvbGxYXCIgOiBcInNjcm9sbFlcIl07XG4gICAgZmFsbGJhY2soKTtcbiAgICBjYihvZmZzZXQsIGlzU2Nyb2xsaW5nKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIodHJ1ZSk7XG4gIGNvbnN0IGVuZEhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKGZhbHNlKTtcbiAgZW5kSGFuZGxlcigpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxlbmRcIiwgZW5kSGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyKTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxlbmRcIiwgZW5kSGFuZGxlcik7XG4gIH07XG59O1xuY29uc3QgbWVhc3VyZUVsZW1lbnQgPSAoZWxlbWVudCwgZW50cnksIGluc3RhbmNlKSA9PiB7XG4gIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgaWYgKGJveCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoXG4gICAgICAgIGJveFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImlubGluZVNpemVcIiA6IFwiYmxvY2tTaXplXCJdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKFxuICAgIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl1cbiAgKTtcbn07XG5jb25zdCB3aW5kb3dTY3JvbGwgPSAob2Zmc2V0LCB7XG4gIGFkanVzdG1lbnRzID0gMCxcbiAgYmVoYXZpb3Jcbn0sIGluc3RhbmNlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHRvT2Zmc2V0ID0gb2Zmc2V0ICsgYWRqdXN0bWVudHM7XG4gIChfYiA9IChfYSA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY3JvbGxUbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICBbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogdG9PZmZzZXQsXG4gICAgYmVoYXZpb3JcbiAgfSk7XG59O1xuY29uc3QgZWxlbWVudFNjcm9sbCA9IChvZmZzZXQsIHtcbiAgYWRqdXN0bWVudHMgPSAwLFxuICBiZWhhdmlvclxufSwgaW5zdGFuY2UpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50cztcbiAgKF9iID0gKF9hID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjcm9sbFRvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgIFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwidG9wXCJdOiB0b09mZnNldCxcbiAgICBiZWhhdmlvclxuICB9KTtcbn07XG5jbGFzcyBWaXJ0dWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IFtdO1xuICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxBZGp1c3RtZW50cyA9IDA7XG4gICAgdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm9ic2VydmVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgICBsZXQgX3JvID0gbnVsbDtcbiAgICAgIGNvbnN0IGdldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKF9ybykge1xuICAgICAgICAgIHJldHVybiBfcm87XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIF9ybyA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gKF9hID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ic2VydmU6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2Eub2JzZXJ2ZSh0YXJnZXQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5vYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgdGhpcy5zZXRPcHRpb25zID0gKG9wdHMyKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhvcHRzMikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgZGVsZXRlIG9wdHMyW2tleV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsT2Zmc2V0OiAwLFxuICAgICAgICBvdmVyc2NhbjogMSxcbiAgICAgICAgcGFkZGluZ1N0YXJ0OiAwLFxuICAgICAgICBwYWRkaW5nRW5kOiAwLFxuICAgICAgICBzY3JvbGxQYWRkaW5nU3RhcnQ6IDAsXG4gICAgICAgIHNjcm9sbFBhZGRpbmdFbmQ6IDAsXG4gICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICBnZXRJdGVtS2V5OiBkZWZhdWx0S2V5RXh0cmFjdG9yLFxuICAgICAgICByYW5nZUV4dHJhY3RvcjogZGVmYXVsdFJhbmdlRXh0cmFjdG9yLFxuICAgICAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBtZWFzdXJlRWxlbWVudCxcbiAgICAgICAgaW5pdGlhbFJlY3Q6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LFxuICAgICAgICBzY3JvbGxNYXJnaW46IDAsXG4gICAgICAgIGdhcDogMCxcbiAgICAgICAgaW5kZXhBdHRyaWJ1dGU6IFwiZGF0YS1pbmRleFwiLFxuICAgICAgICBpbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU6IFtdLFxuICAgICAgICBsYW5lczogMSxcbiAgICAgICAgaXNTY3JvbGxpbmdSZXNldERlbGF5OiAxNTAsXG4gICAgICAgIC4uLm9wdHMyXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5ub3RpZnkgPSAoZm9yY2UsIHN5bmMpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSB0aGlzLnJhbmdlID8/IHtcbiAgICAgICAgc3RhcnRJbmRleDogdm9pZCAwLFxuICAgICAgICBlbmRJbmRleDogdm9pZCAwXG4gICAgICB9O1xuICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZVJhbmdlKCk7XG4gICAgICBpZiAoZm9yY2UgfHwgc3RhcnRJbmRleCAhPT0gKHJhbmdlID09IG51bGwgPyB2b2lkIDAgOiByYW5nZS5zdGFydEluZGV4KSB8fCBlbmRJbmRleCAhPT0gKHJhbmdlID09IG51bGwgPyB2b2lkIDAgOiByYW5nZS5lbmRJbmRleCkpIHtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMsIHN5bmMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuX2RpZE1vdW50ID0gKCkgPT4ge1xuICAgICAgdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmZvckVhY2godGhpcy5vYnNlcnZlci5vYnNlcnZlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLl93aWxsVXBkYXRlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMub3B0aW9ucy5nZXRTY3JvbGxFbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy5zY3JvbGxFbGVtZW50ICE9PSBzY3JvbGxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLnNjcm9sbE9mZnNldCwge1xuICAgICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnN1YnMucHVzaChcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRSZWN0KHRoaXMsIChyZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnVuc3Vicy5wdXNoKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudE9mZnNldCh0aGlzLCAob2Zmc2V0LCBpc1Njcm9sbGluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBZGp1c3RtZW50cyA9IDA7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpcmVjdGlvbiA9IGlzU2Nyb2xsaW5nID8gdGhpcy5zY3JvbGxPZmZzZXQgPCBvZmZzZXQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZJc1Njcm9sbGluZyA9IHRoaXMuaXNTY3JvbGxpbmc7XG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gaXNTY3JvbGxpbmc7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShwcmV2SXNTY3JvbGxpbmcgIT09IGlzU2Nyb2xsaW5nLCBpc1Njcm9sbGluZyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbFJlY3RbdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TWVhc3VyZW1lbnRPcHRpb25zID0gbWVtbyhcbiAgICAgICgpID0+IFtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvdW50LFxuICAgICAgICB0aGlzLm9wdGlvbnMucGFkZGluZ1N0YXJ0LFxuICAgICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsTWFyZ2luLFxuICAgICAgICB0aGlzLm9wdGlvbnMuZ2V0SXRlbUtleVxuICAgICAgXSxcbiAgICAgIChjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXkpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb3VudCxcbiAgICAgICAgICBwYWRkaW5nU3RhcnQsXG4gICAgICAgICAgc2Nyb2xsTWFyZ2luLFxuICAgICAgICAgIGdldEl0ZW1LZXlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogZmFsc2VcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudCA9IChtZWFzdXJlbWVudHMsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAobGV0IG0gPSBpbmRleCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW21dO1xuICAgICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5oYXMobWVhc3VyZW1lbnQubGFuZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPSBmdXJ0aGVzdE1lYXN1cmVtZW50cy5nZXQoXG4gICAgICAgICAgbWVhc3VyZW1lbnQubGFuZVxuICAgICAgICApO1xuICAgICAgICBpZiAocHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID09IG51bGwgfHwgbWVhc3VyZW1lbnQuZW5kID4gcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCkge1xuICAgICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNldChtZWFzdXJlbWVudC5sYW5lLCBtZWFzdXJlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVhc3VyZW1lbnQuZW5kIDwgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCkge1xuICAgICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuc2V0KG1lYXN1cmVtZW50LmxhbmUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVydGhlc3RNZWFzdXJlbWVudHMuc2l6ZSA9PT0gdGhpcy5vcHRpb25zLmxhbmVzID8gQXJyYXkuZnJvbShmdXJ0aGVzdE1lYXN1cmVtZW50cy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS5lbmQgPT09IGIuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmVuZCAtIGIuZW5kO1xuICAgICAgfSlbMF0gOiB2b2lkIDA7XG4gICAgfTtcbiAgICB0aGlzLmdldE1lYXN1cmVtZW50cyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMoKSwgdGhpcy5pdGVtU2l6ZUNhY2hlXSxcbiAgICAgICh7IGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSB9LCBpdGVtU2l6ZUNhY2hlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbiguLi50aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcykgOiAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlLnNsaWNlKDAsIG1pbik7XG4gICAgICAgIGZvciAobGV0IGkgPSBtaW47IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gZ2V0SXRlbUtleShpKTtcbiAgICAgICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50ID0gdGhpcy5vcHRpb25zLmxhbmVzID09PSAxID8gbWVhc3VyZW1lbnRzW2kgLSAxXSA6IHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudChtZWFzdXJlbWVudHMsIGkpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZnVydGhlc3RNZWFzdXJlbWVudCA/IGZ1cnRoZXN0TWVhc3VyZW1lbnQuZW5kICsgdGhpcy5vcHRpb25zLmdhcCA6IHBhZGRpbmdTdGFydCArIHNjcm9sbE1hcmdpbjtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlZFNpemUgPSBpdGVtU2l6ZUNhY2hlLmdldChrZXkpO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSB0eXBlb2YgbWVhc3VyZWRTaXplID09PSBcIm51bWJlclwiID8gbWVhc3VyZWRTaXplIDogdGhpcy5vcHRpb25zLmVzdGltYXRlU2l6ZShpKTtcbiAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHNpemU7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmxhbmUgOiBpICUgdGhpcy5vcHRpb25zLmxhbmVzO1xuICAgICAgICAgIG1lYXN1cmVtZW50c1tpXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbGFuZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IG1lYXN1cmVtZW50cztcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0TWVhc3VyZW1lbnRzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0TWVhc3VyZW1lbnRzKCksIHRoaXMuZ2V0U2l6ZSgpLCB0aGlzLnNjcm9sbE9mZnNldF0sXG4gICAgICAobWVhc3VyZW1lbnRzLCBvdXRlclNpemUsIHNjcm9sbE9mZnNldCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSA9IG1lYXN1cmVtZW50cy5sZW5ndGggPiAwICYmIG91dGVyU2l6ZSA+IDAgPyBjYWxjdWxhdGVSYW5nZSh7XG4gICAgICAgICAgbWVhc3VyZW1lbnRzLFxuICAgICAgICAgIG91dGVyU2l6ZSxcbiAgICAgICAgICBzY3JvbGxPZmZzZXRcbiAgICAgICAgfSkgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJjYWxjdWxhdGVSYW5nZVwiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldEluZGV4ZXMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLm9wdGlvbnMucmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UoKSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJzY2FuLFxuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnRcbiAgICAgIF0sXG4gICAgICAocmFuZ2VFeHRyYWN0b3IsIHJhbmdlLCBvdmVyc2NhbiwgY291bnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJhbmdlID09PSBudWxsID8gW10gOiByYW5nZUV4dHJhY3Rvcih7XG4gICAgICAgICAgc3RhcnRJbmRleDogcmFuZ2Uuc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleDogcmFuZ2UuZW5kSW5kZXgsXG4gICAgICAgICAgb3ZlcnNjYW4sXG4gICAgICAgICAgY291bnRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldEluZGV4ZXNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5pbmRleEZyb21FbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLm9wdGlvbnMuaW5kZXhBdHRyaWJ1dGU7XG4gICAgICBjb25zdCBpbmRleFN0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKCFpbmRleFN0cikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYE1pc3NpbmcgYXR0cmlidXRlIG5hbWUgJyR7YXR0cmlidXRlTmFtZX09e2luZGV4fScgb24gbWVhc3VyZWQgZWxlbWVudC5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUludChpbmRleFN0ciwgMTApO1xuICAgIH07XG4gICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSAobm9kZSwgZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW3RoaXMuaW5kZXhGcm9tRWxlbWVudChub2RlKV07XG4gICAgICBpZiAoIWl0ZW0gfHwgIW5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmZvckVhY2goKGNhY2hlZCwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKGNhY2hlZCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZ2V0KGl0ZW0ua2V5KTtcbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbm9kZSkge1xuICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyLnVub2JzZXJ2ZShwcmV2Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgICAgICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuc2V0KGl0ZW0ua2V5LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lYXN1cmVkSXRlbVNpemUgPSB0aGlzLm9wdGlvbnMubWVhc3VyZUVsZW1lbnQobm9kZSwgZW50cnksIHRoaXMpO1xuICAgICAgdGhpcy5yZXNpemVJdGVtKGl0ZW0sIG1lYXN1cmVkSXRlbVNpemUpO1xuICAgIH07XG4gICAgdGhpcy5yZXNpemVJdGVtID0gKGl0ZW0sIHNpemUpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZUNhY2hlLmdldChpdGVtLmtleSkgPz8gaXRlbS5zaXplO1xuICAgICAgY29uc3QgZGVsdGEgPSBzaXplIC0gaXRlbVNpemU7XG4gICAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQWRqdXN0U2Nyb2xsUG9zaXRpb25Pbkl0ZW1TaXplQ2hhbmdlICE9PSB2b2lkIDAgPyB0aGlzLnNob3VsZEFkanVzdFNjcm9sbFBvc2l0aW9uT25JdGVtU2l6ZUNoYW5nZShpdGVtLCBkZWx0YSwgdGhpcykgOiBpdGVtLnN0YXJ0IDwgdGhpcy5zY3JvbGxPZmZzZXQgKyB0aGlzLnNjcm9sbEFkanVzdG1lbnRzKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImNvcnJlY3Rpb25cIiwgZGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLnNjcm9sbE9mZnNldCwge1xuICAgICAgICAgICAgYWRqdXN0bWVudHM6IHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgKz0gZGVsdGEsXG4gICAgICAgICAgICBiZWhhdmlvcjogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMucHVzaChpdGVtLmluZGV4KTtcbiAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlID0gbmV3IE1hcCh0aGlzLml0ZW1TaXplQ2FjaGUuc2V0KGl0ZW0ua2V5LCBzaXplKSk7XG4gICAgICAgIHRoaXMubm90aWZ5KHRydWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubWVhc3VyZUVsZW1lbnQgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50KG5vZGUsIHZvaWQgMCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFZpcnR1YWxJdGVtcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGhpcy5nZXRJbmRleGVzKCksIHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCldLFxuICAgICAgKGluZGV4ZXMsIG1lYXN1cmVtZW50cykgPT4ge1xuICAgICAgICBjb25zdCB2aXJ0dWFsSXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IGluZGV4ZXMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBpID0gaW5kZXhlc1trXTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICAgICAgICB2aXJ0dWFsSXRlbXMucHVzaChtZWFzdXJlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpcnR1YWxJdGVtcztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0SW5kZXhlc1wiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldFZpcnR1YWxJdGVtRm9yT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5nZXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIHJldHVybiBub3RVbmRlZmluZWQoXG4gICAgICAgIG1lYXN1cmVtZW50c1tmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaChcbiAgICAgICAgICAwLFxuICAgICAgICAgIG1lYXN1cmVtZW50cy5sZW5ndGggLSAxLFxuICAgICAgICAgIChpbmRleCkgPT4gbm90VW5kZWZpbmVkKG1lYXN1cmVtZW50c1tpbmRleF0pLnN0YXJ0LFxuICAgICAgICAgIG9mZnNldFxuICAgICAgICApXVxuICAgICAgKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50ID0gKHRvT2Zmc2V0LCBhbGlnbikgPT4ge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgaWYgKGFsaWduID09PSBcImF1dG9cIikge1xuICAgICAgICBpZiAodG9PZmZzZXQgPD0gdGhpcy5zY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwic3RhcnRcIjtcbiAgICAgICAgfSBlbHNlIGlmICh0b09mZnNldCA+PSB0aGlzLnNjcm9sbE9mZnNldCArIHNpemUpIHtcbiAgICAgICAgICBhbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGlnbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgIHRvT2Zmc2V0ID0gdG9PZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcImVuZFwiKSB7XG4gICAgICAgIHRvT2Zmc2V0ID0gdG9PZmZzZXQgLSBzaXplO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICB0b09mZnNldCA9IHRvT2Zmc2V0IC0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JvbGxTaXplUHJvcCA9IHRoaXMub3B0aW9ucy5ob3Jpem9udGFsID8gXCJzY3JvbGxXaWR0aFwiIDogXCJzY3JvbGxIZWlnaHRcIjtcbiAgICAgIGNvbnN0IHNjcm9sbFNpemUgPSB0aGlzLnNjcm9sbEVsZW1lbnQgPyBcImRvY3VtZW50XCIgaW4gdGhpcy5zY3JvbGxFbGVtZW50ID8gdGhpcy5zY3JvbGxFbGVtZW50LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtzY3JvbGxTaXplUHJvcF0gOiB0aGlzLnNjcm9sbEVsZW1lbnRbc2Nyb2xsU2l6ZVByb3BdIDogMDtcbiAgICAgIGNvbnN0IG1heE9mZnNldCA9IHNjcm9sbFNpemUgLSB0aGlzLmdldFNpemUoKTtcbiAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihtYXhPZmZzZXQsIHRvT2Zmc2V0KSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLmdldE9mZnNldEZvckluZGV4ID0gKGluZGV4LCBhbGlnbiA9IFwiYXV0b1wiKSA9PiB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLm9wdGlvbnMuY291bnQgLSAxKSk7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG5vdFVuZGVmaW5lZCh0aGlzLmdldE1lYXN1cmVtZW50cygpW2luZGV4XSk7XG4gICAgICBpZiAoYWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGlmIChtZWFzdXJlbWVudC5lbmQgPj0gdGhpcy5zY3JvbGxPZmZzZXQgKyB0aGlzLmdldFNpemUoKSAtIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nRW5kKSB7XG4gICAgICAgICAgYWxpZ24gPSBcImVuZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKG1lYXN1cmVtZW50LnN0YXJ0IDw9IHRoaXMuc2Nyb2xsT2Zmc2V0ICsgdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydCkge1xuICAgICAgICAgIGFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbdGhpcy5zY3JvbGxPZmZzZXQsIGFsaWduXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdG9PZmZzZXQgPSBhbGlnbiA9PT0gXCJlbmRcIiA/IG1lYXN1cmVtZW50LmVuZCArIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nRW5kIDogbWVhc3VyZW1lbnQuc3RhcnQgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0O1xuICAgICAgcmV0dXJuIFt0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24pLCBhbGlnbl07XG4gICAgfTtcbiAgICB0aGlzLmlzRHluYW1pY01vZGUgPSAoKSA9PiB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuc2l6ZSA+IDA7XG4gICAgdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4ID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkKTtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsVG9PZmZzZXQgPSAodG9PZmZzZXQsIHsgYWxpZ24gPSBcInN0YXJ0XCIsIGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4KCk7XG4gICAgICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24pLCB7XG4gICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgIGJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsVG9JbmRleCA9IChpbmRleCwgeyBhbGlnbjogaW5pdGlhbEFsaWduID0gXCJhdXRvXCIsIGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5vcHRpb25zLmNvdW50IC0gMSkpO1xuICAgICAgdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4KCk7XG4gICAgICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBbdG9PZmZzZXQsIGFsaWduXSA9IHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXgoaW5kZXgsIGluaXRpYWxBbGlnbik7XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0b09mZnNldCwgeyBhZGp1c3RtZW50czogdm9pZCAwLCBiZWhhdmlvciB9KTtcbiAgICAgIGlmIChiZWhhdmlvciAhPT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRJbkRPTSA9IHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5oYXMoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZ2V0SXRlbUtleShpbmRleClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChlbGVtZW50SW5ET00pIHtcbiAgICAgICAgICAgIGNvbnN0IFt0b09mZnNldDJdID0gdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgYWxpZ24pO1xuICAgICAgICAgICAgaWYgKCFhcHByb3hFcXVhbCh0b09mZnNldDIsIHRoaXMuc2Nyb2xsT2Zmc2V0KSkge1xuICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXgoaW5kZXgsIHsgYWxpZ24sIGJlaGF2aW9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXgoaW5kZXgsIHsgYWxpZ24sIGJlaGF2aW9yIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbEJ5ID0gKGRlbHRhLCB7IGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4KCk7XG4gICAgICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLnNjcm9sbE9mZnNldCArIGRlbHRhLCB7XG4gICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgIGJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5nZXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIGxldCBlbmQ7XG4gICAgICBpZiAobWVhc3VyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbmQgPSB0aGlzLm9wdGlvbnMucGFkZGluZ1N0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdGhpcy5vcHRpb25zLmxhbmVzID09PSAxID8gKChfYSA9IG1lYXN1cmVtZW50c1ttZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbmQpID8/IDAgOiBNYXRoLm1heChcbiAgICAgICAgICAuLi5tZWFzdXJlbWVudHMuc2xpY2UoLXRoaXMub3B0aW9ucy5sYW5lcykubWFwKChtKSA9PiBtLmVuZClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmQgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsTWFyZ2luICsgdGhpcy5vcHRpb25zLnBhZGRpbmdFbmQ7XG4gICAgfTtcbiAgICB0aGlzLl9zY3JvbGxUb09mZnNldCA9IChvZmZzZXQsIHtcbiAgICAgIGFkanVzdG1lbnRzLFxuICAgICAgYmVoYXZpb3JcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsVG9GbihvZmZzZXQsIHsgYmVoYXZpb3IsIGFkanVzdG1lbnRzIH0sIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5tZWFzdXJlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcywgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdHMpO1xuICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHRoaXMub3B0aW9ucy5pbml0aWFsUmVjdDtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQoKSA6IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0O1xuICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSB0aGlzLm9wdGlvbnMuaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlO1xuICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgaXRlbS5zaXplKTtcbiAgICB9KTtcbiAgICB0aGlzLm5vdGlmeShmYWxzZSwgZmFsc2UpO1xuICB9XG59XG5jb25zdCBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCA9IChsb3csIGhpZ2gsIGdldEN1cnJlbnRWYWx1ZSwgdmFsdWUpID0+IHtcbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgY29uc3QgbWlkZGxlID0gKGxvdyArIGhpZ2gpIC8gMiB8IDA7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlKG1pZGRsZSk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IHZhbHVlKSB7XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gdmFsdWUpIHtcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgfVxuICBpZiAobG93ID4gMCkge1xuICAgIHJldHVybiBsb3cgLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2Uoe1xuICBtZWFzdXJlbWVudHMsXG4gIG91dGVyU2l6ZSxcbiAgc2Nyb2xsT2Zmc2V0XG59KSB7XG4gIGNvbnN0IGNvdW50ID0gbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGdldE9mZnNldCA9IChpbmRleCkgPT4gbWVhc3VyZW1lbnRzW2luZGV4XS5zdGFydDtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKDAsIGNvdW50LCBnZXRPZmZzZXQsIHNjcm9sbE9mZnNldCk7XG4gIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIHdoaWxlIChlbmRJbmRleCA8IGNvdW50ICYmIG1lYXN1cmVtZW50c1tlbmRJbmRleF0uZW5kIDwgc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgZW5kSW5kZXgrKztcbiAgfVxuICByZXR1cm4geyBzdGFydEluZGV4LCBlbmRJbmRleCB9O1xufVxuZXhwb3J0IHtcbiAgVmlydHVhbGl6ZXIsXG4gIGFwcHJveEVxdWFsLFxuICBkZWJvdW5jZSxcbiAgZGVmYXVsdEtleUV4dHJhY3RvcixcbiAgZGVmYXVsdFJhbmdlRXh0cmFjdG9yLFxuICBlbGVtZW50U2Nyb2xsLFxuICBtZWFzdXJlRWxlbWVudCxcbiAgbWVtbyxcbiAgbm90VW5kZWZpbmVkLFxuICBvYnNlcnZlRWxlbWVudE9mZnNldCxcbiAgb2JzZXJ2ZUVsZW1lbnRSZWN0LFxuICBvYnNlcnZlV2luZG93T2Zmc2V0LFxuICBvYnNlcnZlV2luZG93UmVjdCxcbiAgd2luZG93U2Nyb2xsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiZGVib3VuY2UiLCJtZW1vIiwibm90VW5kZWZpbmVkIiwiYXBwcm94RXF1YWwiLCJkZWZhdWx0S2V5RXh0cmFjdG9yIiwiaW5kZXgiLCJkZWZhdWx0UmFuZ2VFeHRyYWN0b3IiLCJyYW5nZSIsInN0YXJ0IiwiTWF0aCIsIm1heCIsInN0YXJ0SW5kZXgiLCJvdmVyc2NhbiIsImVuZCIsIm1pbiIsImVuZEluZGV4IiwiY291bnQiLCJhcnIiLCJpIiwicHVzaCIsIm9ic2VydmVFbGVtZW50UmVjdCIsImluc3RhbmNlIiwiY2IiLCJlbGVtZW50Iiwic2Nyb2xsRWxlbWVudCIsImhhbmRsZXIiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZW50cnkiLCJib3JkZXJCb3hTaXplIiwiYm94IiwiaW5saW5lU2l6ZSIsImJsb2NrU2l6ZSIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJhZGRFdmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmUiLCJvYnNlcnZlV2luZG93UmVjdCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3VwcG9ydHNTY3JvbGxlbmQiLCJ3aW5kb3ciLCJvYnNlcnZlRWxlbWVudE9mZnNldCIsIm9mZnNldCIsImZhbGxiYWNrIiwib3B0aW9ucyIsImlzU2Nyb2xsaW5nUmVzZXREZWxheSIsImNyZWF0ZUhhbmRsZXIiLCJpc1Njcm9sbGluZyIsImhvcml6b250YWwiLCJlbmRIYW5kbGVyIiwib2JzZXJ2ZVdpbmRvd09mZnNldCIsIm1lYXN1cmVFbGVtZW50Iiwic2l6ZSIsIndpbmRvd1Njcm9sbCIsImFkanVzdG1lbnRzIiwiYmVoYXZpb3IiLCJfYSIsIl9iIiwidG9PZmZzZXQiLCJzY3JvbGxUbyIsImNhbGwiLCJlbGVtZW50U2Nyb2xsIiwiVmlydHVhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJ1bnN1YnMiLCJzY3JvbGxUb0luZGV4VGltZW91dElkIiwibWVhc3VyZW1lbnRzQ2FjaGUiLCJpdGVtU2l6ZUNhY2hlIiwiTWFwIiwicGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzIiwic2Nyb2xsRGlyZWN0aW9uIiwic2Nyb2xsQWRqdXN0bWVudHMiLCJtZWFzdXJlRWxlbWVudENhY2hlIiwiX3JvIiwiZ2V0IiwiZm9yRWFjaCIsIl9tZWFzdXJlRWxlbWVudCIsInRhcmdldCIsImRpc2Nvbm5lY3QiLCJzZXRPcHRpb25zIiwib3B0czIiLCJPYmplY3QiLCJrZXkiLCJ2YWx1ZSIsImRlYnVnIiwiaW5pdGlhbE9mZnNldCIsInBhZGRpbmdTdGFydCIsInBhZGRpbmdFbmQiLCJzY3JvbGxQYWRkaW5nU3RhcnQiLCJzY3JvbGxQYWRkaW5nRW5kIiwiZ2V0SXRlbUtleSIsInJhbmdlRXh0cmFjdG9yIiwib25DaGFuZ2UiLCJpbml0aWFsUmVjdCIsInNjcm9sbE1hcmdpbiIsImdhcCIsImluZGV4QXR0cmlidXRlIiwiaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlIiwibGFuZXMiLCJub3RpZnkiLCJmb3JjZSIsInN5bmMiLCJjYWxjdWxhdGVSYW5nZSIsImNsZWFudXAiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZCIsIl9kaWRNb3VudCIsIl93aWxsVXBkYXRlIiwiZ2V0U2Nyb2xsRWxlbWVudCIsIl9zY3JvbGxUb09mZnNldCIsInNjcm9sbE9mZnNldCIsInNjcm9sbFJlY3QiLCJwcmV2SXNTY3JvbGxpbmciLCJnZXRTaXplIiwiZ2V0TWVhc3VyZW1lbnRPcHRpb25zIiwiZ2V0RnVydGhlc3RNZWFzdXJlbWVudCIsIm1lYXN1cmVtZW50cyIsImZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQiLCJmdXJ0aGVzdE1lYXN1cmVtZW50cyIsIm0iLCJtZWFzdXJlbWVudCIsImhhcyIsImxhbmUiLCJwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQiLCJzZXQiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJnZXRNZWFzdXJlbWVudHMiLCJsZW5ndGgiLCJzbGljZSIsImZ1cnRoZXN0TWVhc3VyZW1lbnQiLCJtZWFzdXJlZFNpemUiLCJlc3RpbWF0ZVNpemUiLCJwcm9jZXNzIiwib3V0ZXJTaXplIiwiZ2V0SW5kZXhlcyIsImluZGV4RnJvbUVsZW1lbnQiLCJub2RlIiwiYXR0cmlidXRlTmFtZSIsImluZGV4U3RyIiwiZ2V0QXR0cmlidXRlIiwiY29uc29sZSIsIndhcm4iLCJwYXJzZUludCIsIml0ZW0iLCJpc0Nvbm5lY3RlZCIsImNhY2hlZCIsImRlbGV0ZSIsInByZXZOb2RlIiwibWVhc3VyZWRJdGVtU2l6ZSIsInJlc2l6ZUl0ZW0iLCJpdGVtU2l6ZSIsImRlbHRhIiwic2hvdWxkQWRqdXN0U2Nyb2xsUG9zaXRpb25Pbkl0ZW1TaXplQ2hhbmdlIiwiaW5mbyIsImdldFZpcnR1YWxJdGVtcyIsImluZGV4ZXMiLCJ2aXJ0dWFsSXRlbXMiLCJrIiwibGVuIiwiZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQiLCJmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCIsImdldE9mZnNldEZvckFsaWdubWVudCIsImFsaWduIiwic2Nyb2xsU2l6ZVByb3AiLCJzY3JvbGxTaXplIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJtYXhPZmZzZXQiLCJnZXRPZmZzZXRGb3JJbmRleCIsImlzRHluYW1pY01vZGUiLCJjYW5jZWxTY3JvbGxUb0luZGV4IiwiY2xlYXJUaW1lb3V0Iiwic2Nyb2xsVG9PZmZzZXQiLCJzY3JvbGxUb0luZGV4IiwiaW5pdGlhbEFsaWduIiwic2V0VGltZW91dCIsImVsZW1lbnRJbkRPTSIsInRvT2Zmc2V0MiIsInNjcm9sbEJ5IiwiZ2V0VG90YWxTaXplIiwibWFwIiwic2Nyb2xsVG9GbiIsIm1lYXN1cmUiLCJsb3ciLCJoaWdoIiwiZ2V0Q3VycmVudFZhbHVlIiwibWlkZGxlIiwiY3VycmVudFZhbHVlIiwiZ2V0T2Zmc2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n    let deps = opts.initialDeps ?? [];\n    let result;\n    return ()=>{\n        var _a, _b, _c, _d;\n        let depTime;\n        if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n        result = fn(...newDeps);\n        if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n            const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n            const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n            const resultFpsPercentage = resultEndTime / 16;\n            const pad = (str, num)=>{\n                str = String(str);\n                while(str.length < num){\n                    str = \" \" + str;\n                }\n                return str;\n            };\n            console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n        }\n        (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n        return result;\n    };\n}\nfunction notUndefined(value, msg) {\n    if (value === void 0) {\n        throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n    } else {\n        return value;\n    }\n}\nconst approxEqual = (a, b)=>Math.abs(a - b) < 1;\nconst debounce = (fn, ms)=>{\n    let timeoutId;\n    return function(...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(()=>fn.apply(this, args), ms);\n    };\n};\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsU0FBU0EsS0FBS0MsT0FBTyxFQUFFQyxFQUFFLEVBQUVDLElBQUk7SUFDN0IsSUFBSUMsT0FBT0QsS0FBS0UsV0FBVyxJQUFJLEVBQUU7SUFDakMsSUFBSUM7SUFDSixPQUFPO1FBQ0wsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDaEIsSUFBSUM7UUFDSixJQUFJUixLQUFLUyxHQUFHLElBQUssRUFBQ0wsS0FBS0osS0FBS1UsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJTixHQUFHTyxJQUFJLENBQUNYLEtBQUksR0FDaEVRLFVBQVVJLEtBQUtDLEdBQUc7UUFDcEIsTUFBTUMsVUFBVWhCO1FBQ2hCLE1BQU1pQixjQUFjRCxRQUFRRSxNQUFNLEtBQUtmLEtBQUtlLE1BQU0sSUFBSUYsUUFBUUcsSUFBSSxDQUFDLENBQUNDLEtBQUtDLFFBQVVsQixJQUFJLENBQUNrQixNQUFNLEtBQUtEO1FBQ25HLElBQUksQ0FBQ0gsYUFBYTtZQUNoQixPQUFPWjtRQUNUO1FBQ0FGLE9BQU9hO1FBQ1AsSUFBSU07UUFDSixJQUFJcEIsS0FBS1MsR0FBRyxJQUFLLEVBQUNKLEtBQUtMLEtBQUtVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSUwsR0FBR00sSUFBSSxDQUFDWCxLQUFJLEdBQ2hFb0IsYUFBYVIsS0FBS0MsR0FBRztRQUN2QlYsU0FBU0osTUFBTWU7UUFDZixJQUFJZCxLQUFLUyxHQUFHLElBQUssRUFBQ0gsS0FBS04sS0FBS1UsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJSixHQUFHSyxJQUFJLENBQUNYLEtBQUksR0FBSTtZQUNwRSxNQUFNcUIsYUFBYUMsS0FBS0MsS0FBSyxDQUFDLENBQUNYLEtBQUtDLEdBQUcsS0FBS0wsT0FBTSxJQUFLLE9BQU87WUFDOUQsTUFBTWdCLGdCQUFnQkYsS0FBS0MsS0FBSyxDQUFDLENBQUNYLEtBQUtDLEdBQUcsS0FBS08sVUFBUyxJQUFLLE9BQU87WUFDcEUsTUFBTUssc0JBQXNCRCxnQkFBZ0I7WUFDNUMsTUFBTUUsTUFBTSxDQUFDQyxLQUFLQztnQkFDaEJELE1BQU1FLE9BQU9GO2dCQUNiLE1BQU9BLElBQUlYLE1BQU0sR0FBR1ksSUFBSztvQkFDdkJELE1BQU0sTUFBTUE7Z0JBQ2Q7Z0JBQ0EsT0FBT0E7WUFDVDtZQUNBRyxRQUFRQyxJQUFJLENBQ1YsQ0FBQyxJQUFJLEVBQUVMLElBQUlGLGVBQWUsR0FBRyxFQUFFLEVBQUVFLElBQUlMLFlBQVksR0FBRyxHQUFHLENBQUMsRUFDeEQsQ0FBQzs7O3VCQUdjLEVBQUVDLEtBQUtVLEdBQUcsQ0FDdkIsR0FDQVYsS0FBS1csR0FBRyxDQUFDLE1BQU0sTUFBTVIscUJBQXFCLE1BQzFDLGNBQWMsQ0FBQyxFQUNqQnpCLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtTLEdBQUc7UUFFcEM7UUFDQ0YsQ0FBQUEsS0FBS1AsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS2tDLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSTNCLEdBQUdJLElBQUksQ0FBQ1gsTUFBTUc7UUFDOUUsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsU0FBU2dDLGFBQWFDLEtBQUssRUFBRUMsR0FBRztJQUM5QixJQUFJRCxVQUFVLEtBQUssR0FBRztRQUNwQixNQUFNLElBQUlFLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRUQsTUFBTSxDQUFDLEVBQUUsRUFBRUEsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ2hFLE9BQU87UUFDTCxPQUFPRDtJQUNUO0FBQ0Y7QUFDQSxNQUFNRyxjQUFjLENBQUNDLEdBQUdDLElBQU1uQixLQUFLb0IsR0FBRyxDQUFDRixJQUFJQyxLQUFLO0FBQ2hELE1BQU1FLFdBQVcsQ0FBQzVDLElBQUk2QztJQUNwQixJQUFJQztJQUNKLE9BQU8sU0FBUyxHQUFHQyxJQUFJO1FBQ3JCQyxhQUFhRjtRQUNiQSxZQUFZRyxXQUFXLElBQU1qRCxHQUFHa0QsS0FBSyxDQUFDLElBQUksRUFBRUgsT0FBT0Y7SUFDckQ7QUFDRjtBQU1FLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmNtYXotbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvZGlzdC9lc20vdXRpbHMuanM/NDk3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBtZW1vKGdldERlcHMsIGZuLCBvcHRzKSB7XG4gIGxldCBkZXBzID0gb3B0cy5pbml0aWFsRGVwcyA/PyBbXTtcbiAgbGV0IHJlc3VsdDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgbGV0IGRlcFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmICgoX2EgPSBvcHRzLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRzKSkpXG4gICAgICBkZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBuZXdEZXBzID0gZ2V0RGVwcygpO1xuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XG4gICAgaWYgKCFkZXBzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gICAgbGV0IHJlc3VsdFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmICgoX2IgPSBvcHRzLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRzKSkpXG4gICAgICByZXN1bHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXN1bHQgPSBmbiguLi5uZXdEZXBzKTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYyA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKG9wdHMpKSkge1xuICAgICAgY29uc3QgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICBjb25zdCByZXN1bHRFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHJlc3VsdFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICBjb25zdCBwYWQgPSAoc3RyLCBudW0pID0+IHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgc3RyID0gXCIgXCIgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH07XG4gICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgIGAlY+KPsSAke3BhZChyZXN1bHRFbmRUaW1lLCA1KX0gLyR7cGFkKGRlcEVuZFRpbWUsIDUpfSBtc2AsXG4gICAgICAgIGBcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogLjZyZW07XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGNvbG9yOiBoc2woJHtNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKDEyMCAtIDEyMCAqIHJlc3VsdEZwc1BlcmNlbnRhZ2UsIDEyMClcbiAgICAgICAgKX1kZWcgMTAwJSAzMSUpO2AsXG4gICAgICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMua2V5XG4gICAgICApO1xuICAgIH1cbiAgICAoX2QgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChvcHRzLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBub3RVbmRlZmluZWQodmFsdWUsIG1zZykge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB1bmRlZmluZWQke21zZyA/IGA6ICR7bXNnfWAgOiBcIlwifWApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgYXBwcm94RXF1YWwgPSAoYSwgYikgPT4gTWF0aC5hYnMoYSAtIGIpIDwgMTtcbmNvbnN0IGRlYm91bmNlID0gKGZuLCBtcykgPT4ge1xuICBsZXQgdGltZW91dElkO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gZm4uYXBwbHkodGhpcywgYXJncyksIG1zKTtcbiAgfTtcbn07XG5leHBvcnQge1xuICBhcHByb3hFcXVhbCxcbiAgZGVib3VuY2UsXG4gIG1lbW8sXG4gIG5vdFVuZGVmaW5lZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIm1lbW8iLCJnZXREZXBzIiwiZm4iLCJvcHRzIiwiZGVwcyIsImluaXRpYWxEZXBzIiwicmVzdWx0IiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJkZXBUaW1lIiwia2V5IiwiZGVidWciLCJjYWxsIiwiRGF0ZSIsIm5vdyIsIm5ld0RlcHMiLCJkZXBzQ2hhbmdlZCIsImxlbmd0aCIsInNvbWUiLCJkZXAiLCJpbmRleCIsInJlc3VsdFRpbWUiLCJkZXBFbmRUaW1lIiwiTWF0aCIsInJvdW5kIiwicmVzdWx0RW5kVGltZSIsInJlc3VsdEZwc1BlcmNlbnRhZ2UiLCJwYWQiLCJzdHIiLCJudW0iLCJTdHJpbmciLCJjb25zb2xlIiwiaW5mbyIsIm1heCIsIm1pbiIsIm9uQ2hhbmdlIiwibm90VW5kZWZpbmVkIiwidmFsdWUiLCJtc2ciLCJFcnJvciIsImFwcHJveEVxdWFsIiwiYSIsImIiLCJhYnMiLCJkZWJvdW5jZSIsIm1zIiwidGltZW91dElkIiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhcHBseSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\n");

/***/ })

};
;